### TCP、UDP 的特点
+ `TCP`是一个面向连接的`传输层`协议。是可靠的、基于字节流的；`TCP`还具有`超时重传`、`拥塞控制`的机制；
+ 而UDP是一个无连接的传输层协议。
  
面向连接指的是需要三次握手建立链接

可靠性指 `TCP` 具有 确认应答`ACK` 和 `序列号`来实现可靠传输；

基于字节流指的是：`UDP`的传输是将一个完整的用户消息发送一个`UDP`报文；而`TCP`是将一条用户消息根据滑动窗口的字节大小，拆分成多个`TCP`报文段（`TCP`将数据看作一连串字节流）

### TCP 和 UDP 的区别
+ `TCP` 是面向连接的，`UDP` 是无连接的即发送数据前不需要先建立链接
+ `TCP` 是可靠传输，保证数据正确且有序；`UDP`是不可靠的，可能`丢包`或`乱序`
+ `TCP` 是面向字节流，`UDP` 面向报文，并且网络出现拥塞不会使得发送速率降低
+ `TCP` 首部开销大，最小`20`字节最大`60`字节，而 `UDP` 首部开销小，仅`8`字节
+ `TCP` 只能是 `1` 对 `1` 的，`UDP` 支持 `1对1`, `1 对多`；


### HTTP 和 TCP 的不同
+ `HTTP`的责任是去定义数据，在两台计算机相互传递信息时，`HTTP`规定了每段数据以什么形式表达才是能够被另外一台计算机理解
+ 而`TCP`所要规定的是数据应该怎么传输才能稳定且高效

### TCP 的可靠性
+ 序列号: `TCP`给每一个包一个序号，保证接收端的按序接受；
+ 确认应答ACK: 接收端收到包就会回一个相应的确认ACK，如果发送端在一个往返时延内未收到确认就会重传；
+ 流量控制：通过控制发送者的发送速度来缓解接收者的拥塞；
+ 拥塞控制：当网络出现拥塞的时候，TCP能够减小向网络注入数据的速率和数量，缓解拥塞；

### 流量控制 和 拥塞控制 的区别
+ `流量控制` 是作用于接收者的，它是控制发送者的发送速度从而使接收者来得及接收，防止丢失数据包的。
+ `拥塞控制` 是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况


### 流量控制机制 & 滑动窗口
+ 对于发送端和接收端来说，`TCP`需要将发送的数据放到发送缓冲区，接收的数据放到接收缓冲区；
+ 而流量控制的目的，就是为了提供一种机制：让发送端可以根据接收端的实际接受能力控制发送的数据量；
+ `TCP`通过滑动窗口实现流量控制的机制，而滑动窗口大小是通过TCP首部的窗口大小字段来通知对方
+ `TCP`协议的头部信息中，有一个16位字段的窗口大小，窗口大小的内容就是接收端接收数据缓冲区的剩余大小；当接收端缓冲区面临溢出时，就会设置成一个更小值取告诉发送端要控制发送的数据量；发送端收到后就会对数据发送量进行调整，形成完整的流量控制；


### 拥塞控制机制
体现在四个方面
+ `慢启动`：开始的时候不要发送大量数据，先测试一下网络，然后慢慢由小到大的增加拥塞窗口大小；直到达到慢启动阈值；
+ `拥塞避免`：一旦判断网络出现拥塞，就将慢启动阈值设置为出现拥塞时一半的大小，并把拥塞窗口设为1，再重新开始慢启动算法
+ `快速重传`：就是接收方在收到一个失序的报文后立即发出重复确认，快重传算法规定发送方只要连续收到三个重复确认就立即重传对方尚未收到的报文段，而不用继续等重传计时器到期；
+ `快速恢复`：当发送方连续收到三个重复确认时，就不执行慢启动算法而是执行拥塞避免算法；

拥塞窗口 是指发送端还可以传输的数据量大小，上文提到有通过流量控制机制来限制发送窗口的大小，而最终会取两者之间的较小值；

## 三次握手
### TCP 三次握手流程
+ 第一步：客户端发送`SYN`报文到服务端发起握手
+ 第二步：服务端收到`SYN`报文之后回复`SYN`和`ACK`报文给客户端
+ 第三步：客户端收到`SYN`和`ACK`，向服务端发送一个`ACK`报文

### TCP 快速打开（TFO）
`TFO` 就是为了减少三次握手带来的延时，
+ 在 `TFO` 的流程中，首轮三次握手服务端会计算得到一个 `TFO cookie`，放到 `TCP` 报文的 `Fast Open`里面
+ 客户端拿到这个 `cookie` 后缓存下来，并完成正常的三次握手；
+ 下一次的三次握手，客户端就会将之前的 `cookie` 和 `HTTP`请求、`SYN` 发给服务端
+ 服务端验证 `cookie` 是否合法，如果合法就正常返回 `SYN+ACK`；并且返回`HTTP`响应；
+ 最后完成三次握手的剩余流程；

### 三次握手的意义
客户端和服务端都需要直到各自可收发，因此需要三次握手
+ 第一次握手成功让服务端知道了客户端具有发送能力
+ 第二次握手成功让客户端知道了服务端具有接收和发送能力，但此时服务端并不知道客户端是否接收到了自己发送的消息（如果服务端这时立刻给客户端发送数据，这个时候客户端可能还没有准备好接收数据）
+ 第三次握手让服务端知道了客户端做好了接收自己发送的消息的准备

### 为什么 TCP 建立连接需要三次握手，而不是两次
+ 因为这是为了防止出现失效的连接请求报文段被服务端接收的情况，从而产生错误。

### 三次握手过程中可以携带数据吗
+ `第一次`、`第二次`握手不可以携带数据，因为一握二握时还没有建立连接，会让服务器容易受到攻击（只需要在第一次握手的报文里放大量数据，服务器就会消耗更大的时间和内存空间去处理数据）
+ 而第三次握手，此时客户端已经处于 `(已建立连接状态)` ，对于客户端来说，已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据也是没问题的。

## 四次挥手
### 为什么要四次挥手 & 四次挥手流程
因为`TCP`是全双工通信，不能单方面完全断开连接
+ 第一次挥手，客户端发送`FIN`给服务端
+ 第二次挥手，服务端回复`ACK`给客户端，服务端还可以继续向客户端发送数据（若数据没有发送完）
+ 第三次挥手，服务端发送`FIN`给客户端
+ 第四次挥手，客户端回复`ACK`给服务端，客户端经过 `2MSL` 的时间后断开，服务端接收到了客户端发出的ACK后立刻断开了到客户端的连接

至此TCP连接才完全断开。

### 四次挥手结束等待 2MSL 的意义
+ 虽然按道理，四个报文都发送完毕，就可以立即断开，但是我们必须假设网络是不可靠的，有可以最后一个`ACK`丢失。
+ 如果最后一个 `ACK` 丢失了，那么服务端没有收到 `ACK` 就会发起重传；再次发送 `FIN` 给客户端；
+ 客户端收到重传的 `FIN` 后，会重发 `ACK` 并重新等待 `2MSL` 的时间来确保服务端收到了自己的 `ACK`；

总结：
+ 1 个 `MSL` 确保第四次挥手中主动关闭方最后的 `ACK` 报文最终能达到对端
+ 1 个 `MSL` 确保对端没有收到 `ACK` 重传的 FIN 报文可以到达