# VirtualDOM & DIFF算法
## 虚拟DOM 的产生和本质
+ 由于在浏览器中操作`DOM`是很昂贵的。频繁的操作`DOM`，会产生一定的性能问题。使用虚拟`DOM`可以减少直接操作`DOM`的次数，减少浏览器的重绘及回流
+ `Virtual DOM` 本质就是用一个原生的`JS对象`去描述一个`DOM节点`。是对真实`DOM`的一层抽象
+ `Virtual DOM` 映射到真实`DOM`要经历`VNode`的`create`、`diff`、`patch`等阶段
 
## 虚拟DOM 的作用
+ 将真实元素节点抽象成 `VNode`，有效减少直接操作 `dom` 次数，从而提高程序性能
+ 方便实现跨平台：可以使用虚拟`DOM`去针对不同平台进行渲染；

## Diff算法 实现原理
+ 首先，对比新旧节点（VNode）本身，判断是否为同一节点，如果不为相同节点，则删除该节点重新创建节点进行替换；
+ 如果为相同节点，就要判断如何对该节点的子节点进行处理，这里有四种情况：
  + `旧节点`有`子节点`，`新节点`没有`子节点`，就直接删除`旧节点`的`子节点`；
  + `旧节点`没有`子节点`，`新节点`有`子节点`，就将新节点的子节点添加到旧节点上；
  + 新旧节点都没有子节点，就判断是否有文本节点进行对比；


## Diff算法 的执行时机
`Vue` 中 `Diff算法` 执行的时刻是组件更新的时候，更新函数会再次执行 `render` 函数获得最新的`虚拟DOM`，然后执行`patch`函数，并传入新旧两次`虚拟DOM`，通过比对两者找到变化的地方，最后将其转化为对应的`DOM`操作。


## DIFF算法为什么是 O(n) 复杂度而不是 O(n^3)
+ 正常`Diff`两个树的时间复杂度是`O(n^3)`，但实际情况下我们很少会进行跨层级的移动`DOM`，所以Vue将Diff进行了优化，只对同层的子节点进行比较，放弃跨级的节点比较，使得时间复杂从O(n^3)降低至O(n)。

## Vue2 Diff算法 双端比较 原理
使用了四个`指针`，分别指向新旧两个 `VNode` 的头尾，它们不断的往中间移动，当处理完所有 `VNode` 时停止，每次移动都要比较 `头头`、`头尾` 排列组合共`4`次对比，来去寻找 `key` 相同的可复用的节点来进行移动复用；

## Vue3 Diff算法 最长递增子序列
`vue3` 为了尽可能的减少移动，采用 `贪心` + `二分查找` 去找`最长递增子序列`；
