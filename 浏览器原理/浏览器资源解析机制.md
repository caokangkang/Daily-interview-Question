# 浏览器资源解析机制

## 整体流程
+ 浏览器开始解析`HTML`，此时`document.readystate`为`loading`
+ 解析中遇到不带`async`和`defer`的`script`脚本时，需要等待 `script` 脚本 下载完成并执行后，才会继续解析 `HTML`
+ 当文档完成解析，`document.readyState`变成 `interactive`，触发 `DOMContentLoaded`事件


## 浏览器解析 不同资源 时的行为
+ 浏览器解析遇到 `CSS样式资源` 时，`CSS`会异步下载，不会阻塞浏览器构建`DOM`树，但是会阻塞渲染，在构建渲染树时，会等`css`下载解析完毕后才进行（防止`css`规则不断变化）
+ 浏览器解析遇到 `JS脚本资源` 时，需要等待`JS脚本`下载完成并执行后才会继续解析`HTML`；但是当脚本加上`defer`与`async`时又不一样，`defer`是延迟执行，`async`是异步执行；
+ `CSS`加载会阻塞后面的的`JS`语句的执行，因为`HTML5`标准中有一项规定，浏览器在执行`Script`脚本前，必须保证当前的的外联`CSS`已经解析完成，因为`JS`可能会去获取或者变更`DOM`的`CSS`样式，如果此时外联`CSS`还没解析好，获取到的结果就是不准确的；
+ 解析遇到 `Img图片` 时，直接异步下载，不会阻塞解析；下载完毕后用图片替换原有`src`的地方；
+ 总结：
  + `CSS` 会阻塞浏览器渲染；
  + `JS` 会阻塞浏览器解析；
  + `CSS` 会阻塞后面的JS执行；
  + `IMG` 不会阻塞；
### 为什么css要放在头部
+ 外链`css`无论放在`html`的任何位置都不会影响`html`的解析，但是会影响`html`的渲染；
+ 果将`css`放在尾部，`html`的解析不受影响，浏览器会在 `css` 样式加载解析完后，重新计算样式绘制，造成`回流重绘`、`页面闪动`等现象；
+ 而如果将`css`放在头部，`css`的下载解析时可以和`html`的解析并行，并且会等待`css`下载解析完毕后开始绘制；


### 为什么Script要放在尾部
+ 因为当浏览器解析到 `script` 时，就会立即下载执行，中断 `html` 的解析过程，因为 `js` 可能会修改 `dom` 元素；如果外部脚本加载时间长，就会造成网页长时间未响应；


### async 和 defer 的解析过程
+ 浏览器解析到带 `async` 属性的 `script` 标签时，不会中断 `html` 解析，而是并行下载脚本；当脚本下载完成后，中断解析并执行脚本；
+ 浏览器解析到带 `defer` 属性的 `script` 标签时，不会中断 `html` 解析，而是并行下载脚本；当浏览器解析完`HTML`时、`DOMContentLoaded` 事件即将被触发时，此时再执行下载完成的脚本；


### async 和 defer 的区别
+ `async` 和 `defer` 都仅对外部脚本有效
+ `async` 标志的脚本文件一旦`加载完成就立即执行`；而 `defer` 标志的脚本文件会在 `HTML解析完成且DOM构建完毕`后再执行；（也就是说`defer`是延迟执行，`async`是异步执行）
+ 如果有多个`js`脚本，`async`标记的脚本哪个先下载结束，就先执行那个脚本。而`defer`标记则会按照`js`脚本书写顺序执行。
+ 如果同时使用`async`和`defer`属性，`defer`不起作用，浏览器行为由`async`属性决定。
+ `DOMContentLoaded` 事件会等待 `defer` 的脚本执行完后才触发；


## DOM树 和 CSSOM树 的构建顺序关系
+ 实际上，构建 `DOM树` 和 构建 `CSSOM树` 是并行的；这也正解释了为什么`CSS`加载不会阻塞`DOM`解析，但是因为渲染树需要依赖`DOM树`和`CSSOM树`，所以会阻塞DOM渲染；

## CSS 解析规则
+ 浏览器解析 `CSS` 选择器的方式是从上到下、`从右到左`，因为从右往左只需要最右边的一个不匹配，就可以直接舍弃，避免了许多无效匹配。
+ **一句话总结**： 浏览器的这种查找规则是为了 尽早过滤掉一些无关的样式规则和元素。


## Load 和 DOMContentLoaded 区别
+ `Load` 事件触发代表页面中的 `DOM`，`CSS`，`JS`，图片已经全部加载完毕。
+ `DOMContentLoaded` 事件触发代表初始的 HTML 被完全加载和解析，不需要等待 `CSS`，带 `async` 的 `JS`，图片加载；此时所有的`DOM`都构建完毕；
+ 在应用场景下：
  + 如果我们想在回调中操作`dom`：添加、删除某些元素时，使用`domcontentloaded`；
  + 如果想知道图片宽高、`iframe`内容等资源信息，需要在`load`事件里处理；